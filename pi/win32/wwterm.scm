; Copyright (c) 1998-99 Inujima, Masaru <qfwfq@kt.rim.or.jp>
;
; Permission to use, copy, modify, and distribute this software for any
; purpose with or without fee is hereby granted, provided that the above
; copyright notice and this permission notice appear in all copies.
;
; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

;;;; @(#)$Id: wwterm.scm,v 1.2 2004/08/06 05:48:06 qfwfq Exp $
; $Log: wwterm.scm,v $
; Revision 1.2  2004/08/06 05:48:06  qfwfq
; change license, using OpenBSD:/usr/share/misc/license.template
;
; Revision 1.1  1998/07/31 11:34:36  qfwfq
; First release of ww library
;

(rp:use-macro-package "w_base.scm")
(rp:use-macro-package "w_msg.scm")
(rp:use-macro-package "w_c_edit.scm")
(rp:use-macro-package "w_key.scm")

(define rp:ww-create-terminal-window
  (let ((char-buffer (rp:make-external-buffer 2))
	(intr-disp (rp:cast-buffer->integer (rp:export-string "^C"))))
    (let ((store-char (lambda (c) (rp:store-external-halfword char-buffer 0 #f (rp:char->integer c))))
	  (buffer-lparam (rp:cast-buffer->integer char-buffer))
	  (buffer-lparam2 (rp:+ (rp:cast-buffer->integer char-buffer) 4)))
      (let ((output-proc (lambda (rcv wnd)
			   (let loop () (store-char (rcv))
					(rp:win32api-send-message wnd (win:em replacesel) 0 buffer-lparam)
					(loop))))
	    (send-to-process (lambda (snd str wnd pre-en post-en)
			       (snd 'newline)
			       (if pre-en (begin (rp:win32api-enable-window wnd 0) (snd #t)))
			       (let ((ln (rp:- (rp:string-length str) 1)))
				 (do ((i 0 (rp:+ i 1)))
				     ((rp:= i ln)
				      (if post-en (snd #f))
				      (snd (rp:string-ref str ln))
				      (if post-en (rp:win32api-enable-window wnd 1)))
				     (snd (rp:string-ref str i))))))
	    (get-column (lambda (wnd)
			  (rp:win32api-send-message wnd (win:em getsel) buffer-lparam 0)
			  (rp:- (rp:integer-array-load char-buffer 0)
				(rp:win32api-send-message wnd (win:em lineindex) #xffffffff 0))))
	    (get-line-text (lambda (wnd ln col)
			     (let ((c0 (rp:win32api-send-message wnd (win:em lineindex) ln 0)))
			       (let ((cc (rp:win32api-send-message wnd (win:em linelength) c0 0)))
				 (let ((buf (rp:make-external-buffer (rp:quotient (rp:+ cc 6) 4))))
				   (rp:store-external-halfword buf 0 #f cc)
				   (rp:win32api-send-message wnd (win:em getline) ln (rp:cast-buffer->integer buf))
				   (rp:store-external-chars buf cc (rp:fancy-string #x0d #x0a 0) 3)
				   (let ((str (rp:load-external-chars buf col #f)))
				     (rp:destroy-external-buffer buf)
				     str))))))
	    (edit-ok (lambda (wnd col)
		       (if (rp:= (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1)
				 (rp:win32api-send-message wnd (win:em linefromchar) #xffffffff 0))
			 (begin (rp:win32api-send-message wnd (win:em getsel) buffer-lparam 0)
				(rp:<= (rp:+ (rp:win32api-send-message wnd (win:em lineindex) #xffffffff 0) col)
				       (rp:integer-array-load char-buffer 0)))
			 #f)))
	    (check-caret-pos (lambda (wnd col test)
			       (if (rp:= (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1)
					 (rp:win32api-send-message wnd (win:em linefromchar) #xffffffff 0))
				 (begin (rp:win32api-send-message wnd (win:em getsel) buffer-lparam buffer-lparam2)
					(test (rp:+ (rp:win32api-send-message wnd (win:em lineindex) #xffffffff 0) col)
					      (rp:integer-array-load char-buffer 0)
					      (rp:integer-array-load char-buffer 1)))
				 #f)))
	    (check-and-do (lambda (test do) (if test (do) (begin (rp:win32api-message-beep 0) 0)))))
	(let ((terminal-wndproc
	       (lambda (wnd proc)
		 (let ((oport (rp:with-output-port-as-channel (lambda (rcv) (output-proc rcv wnd)))))
		   (let ((snd (rp:with-channel-as-input-port (lambda (iport) (proc iport oport))))
			 (start-column #f))
		     (set! start-column (get-column wnd))
		     (rp:ww-subclass-dispatcher (wnd message wparam lparam)
		       ((win:wm enable)
			(if (rp:not (rp:zero? wparam))
			  (if (rp:not (rp:win32api-get-focus))
			    (rp:win32api-set-focus wnd)))
			(rp:ww-call-base-procedure wnd message wparam lparam))
		       ((win:wm keydown)
			(cond ((rp:= wparam (win:vk delete))
			       (check-and-do (check-caret-pos wnd start-column
					       (lambda (spos beg end)
						 (if (rp:= beg end)
						   (if (rp:< (rp:win32api-get-key-state (win:vk shift)) 0)
						     (rp:< spos beg) (rp:<= spos beg))
						   (rp:<= spos beg))))
					     (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
			      ((rp:= wparam (win:vk cancel))
			       (rp:ww-call-base-procedure wnd message wparam lparam)
			       (let ((ce (rp:win32api-send-message wnd (win:wm gettextlength) 0 0)))
				 (rp:win32api-send-message wnd (win:em setsel) ce ce))
			       (rp:win32api-send-message wnd (win:em scrollcaret) 0 0)
			       (rp:win32api-send-message wnd (win:em replacesel) 0 intr-disp)
			       (rp:win32api-send-message wnd (win:em emptyundobuffer) 0 0)
			       (rp:win32api-enable-window wnd 0)
			       (snd (rp:list 109 (rp:list 'rp:ww-terminal-interrupt
							  (lambda (port) (rp:display "Interrupt" port)))))
			       (rp:win32api-enable-window wnd 1)
			       (set! start-column (get-column wnd))
			       0)
			      (else (rp:ww-call-base-procedure wnd message wparam lparam))))
		       ((win:wm char)
			(cond ((rp:<= #x20 wparam)
			       (check-and-do (edit-ok wnd start-column)
					     (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
			      ((rp:= wparam #x08)
			       (check-and-do (check-caret-pos wnd start-column
					       (lambda (spos beg end)
						 (if (rp:= beg end) (rp:< spos beg) (rp:<= spos beg))))
					     (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
			      ((rp:= wparam #x09)
			       (check-and-do (edit-ok wnd start-column)
					     (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
			      ((rp:= wparam #x0a)
			       (check-and-do (edit-ok wnd start-column)
				 (lambda ()
				   (let ((ln (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1)))
				     (rp:ww-call-base-procedure wnd message wparam lparam)
				     (rp:win32api-send-message wnd (win:em emptyundobuffer) 0 0)
				     (send-to-process snd (get-line-text wnd ln start-column) wnd #t #t)
				     (set! start-column (get-column wnd))
				     0))))
			      ((rp:= wparam #x0d)
			       (let ((ln (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1))
				     (ce (rp:win32api-send-message wnd (win:wm gettextlength) 0 0)))
				 (if (if (rp:< (rp:win32api-get-key-state (win:vk shift)) 0)
				       (begin (rp:win32api-send-message wnd (win:em setsel) ce ce)
					      (rp:win32api-send-message wnd (win:em scrollcaret) 0 0)
					      #t)
				       (begin (rp:win32api-send-message wnd (win:em getsel) buffer-lparam 0)
					      (rp:= (rp:integer-array-load char-buffer 0) ce)))
				   (begin (rp:ww-call-base-procedure wnd message wparam lparam)
					  (rp:win32api-send-message wnd (win:em emptyundobuffer) 0 0)
					  (send-to-process snd (get-line-text wnd ln start-column) wnd #t #t)
					  (set! start-column (get-column wnd)))
				   (rp:win32api-message-beep 0)))
			       0)
			      (else (rp:ww-call-base-procedure wnd message wparam lparam))))
		       ((win:wm clear)
			(check-and-do (edit-ok wnd start-column)
				      (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
		       ((win:wm cut)
			(check-and-do (edit-ok wnd start-column)
				      (lambda () (rp:ww-call-base-procedure wnd message wparam lparam))))
		       ((win:wm paste)
			(check-and-do (edit-ok wnd start-column)
			  (lambda ()
			    (let ((ln (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1)))
			      (rp:ww-call-base-procedure wnd message wparam lparam)
			      (let ((ll (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1)))
				(if (rp:not (rp:= ln ll))
				  (begin
				    (rp:win32api-send-message wnd (win:em emptyundobuffer) 0 0)
				    (do ((ln ln (rp:win32api-send-message wnd (win:em linefromchar) #xffffffff 0))
					 (ll ll (rp:- (rp:win32api-send-message wnd (win:em getlinecount) 0 0) 1))
					 (col start-column (get-column wnd))
					 (en #t #f))
					((rp:= ln ll) (set! start-column col))
				      (let ((c0 (rp:win32api-send-message wnd (win:em lineindex) (rp:+ ln 1) 0)))
					(rp:win32api-send-message wnd (win:em setsel) c0 c0))
				      (rp:win32api-send-message wnd (win:em scrollcaret) 0 0)
				      (send-to-process snd (get-line-text wnd ln col) wnd en (rp:= (rp:+ ln 1) ll))))))
			      0))))))))))
	  (lambda (proc style x y w h parent id)
	    (let ((wnd (rp:ww-create-child-window "EDIT" (rp:bitwise-or style (win:es multiline)) x y w h parent id))
		  (removal #f))
	      (rp:win32api-enable-window wnd 0)
	      (set! removal (rp:ww-replace-window-procedure wnd (terminal-wndproc wnd proc)))
	      (rp:win32api-enable-window wnd 1)
	      (cons wnd removal))))))))
